import fs from 'fs';
import path, { dirname } from 'path';
import { fileURLToPath } from 'url';
import { fileExistsSync, fileExists } from '@shopify/cli-kit/node/fs';
import { outputWarn, outputInfo } from '@shopify/cli-kit/node/output';
import { joinPath } from '@shopify/cli-kit/node/path';
import { AbortError } from '@shopify/cli-kit/node/error';

const deployDefaults = {
  assetsDirDefault: "dist/client/",
  buildCommandDefault: "npm build",
  verificationDurationDefault: 180,
  maxUploadAttempts: 3,
  maxResumabeUploadAttempts: 9,
  workerDirDefault: "dist/worker/"
};
function errorHandler(error) {
  if (isClientError(error)) {
    if (error.statusCode === 401) {
      throw new AbortError(
        "You are not authorized to perform this action. Please check your deployment token."
      );
    }
    if (error.statusCode === 429) {
      throw new AbortError(
        "You've made too many requests. Please try again later"
      );
    }
  }
  if (error instanceof AbortError && error.message.includes("503")) {
    throw new AbortError(
      "The server is currently unavailable. Please try again later."
    );
  }
}
function getBuildCommandFromLockFile(config) {
  const lockFileBuildCommands = /* @__PURE__ */ new Map([
    ["package-lock.json", "npm run build"],
    ["pnpm-lock.yaml", "pnpm run build"],
    ["yarn.lock", "yarn build"]
  ]);
  const foundLockFiles = [];
  for (const [lockFileName, buildCommand] of lockFileBuildCommands) {
    if (fileExistsSync(joinPath(config.rootPath, lockFileName))) {
      foundLockFiles.push({ lockFileName, buildCommand });
    }
  }
  if (foundLockFiles.length > 1) {
    const lockFilesList = foundLockFiles.map(({ lockFileName }) => lockFileName).join(", ");
    outputWarn(
      `Warning: Multiple lock files found: (${lockFilesList}).`,
      stderrLogger
    );
  }
  if (foundLockFiles.length > 0) {
    const { lockFileName, buildCommand } = foundLockFiles[0];
    const infoMsg = foundLockFiles.length > 1 ? "" : `Found: ${lockFileName}. `;
    outputInfo(
      `${infoMsg}Assuming "${buildCommand}" as build command. Use the buildCommand flag to override.`,
      stderrLogger
    );
    return buildCommand;
  }
  return String(deployDefaults.buildCommandDefault);
}
var Header = /* @__PURE__ */ ((Header2) => {
  Header2["OxygenNamespaceHandle"] = "X-Oxygen-Namespace-Handle";
  return Header2;
})(Header || {});
function isClientError(error) {
  return typeof error === "object" && error !== null && "statusCode" in error;
}
function loadPackageJson(projectFolder) {
  let jsonPath;
  if (projectFolder) {
    jsonPath = path.join(projectFolder, "package.json");
  } else {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    jsonPath = path.join(__dirname, "../../package.json");
  }
  if (!fs.existsSync(jsonPath)) {
    return {};
  }
  const packageJsonData = fs.readFileSync(jsonPath, "utf8");
  return JSON.parse(packageJsonData);
}
function stderrLogger(log) {
  process.stderr.write(`${log}
`);
}
const maxLabelLength = 375;
function parseToken(inputToken) {
  try {
    const decodedToken = Buffer.from(inputToken, "base64").toString("utf-8");
    const rawToken = JSON.parse(decodedToken);
    return convertKeysToCamelCase(rawToken);
  } catch (error) {
    throw new Error(
      `Error processing deployment token. Please check your token and try again.`
    );
  }
}
function authBypassTokenDurationParse(authBypassTokenDurationFlag) {
  if (!authBypassTokenDurationFlag) {
    return void 0;
  }
  const duration = Number(authBypassTokenDurationFlag);
  if (isNaN(duration)) {
    throw new AbortError(
      "Invalid duration format. Please specify the duration in hours (e.g., '10')."
    );
  }
  if (duration > 12 || duration < 1) {
    throw new AbortError(
      "Invalid duration length. Please specify the duration (in hours) between 1 to 12 hours."
    );
  }
  return duration;
}
async function verifyConfig({
  config,
  performedBuild = false
}) {
  const { rootPath, workerDir, assetsDir, skipBuild, workerOnly } = config;
  const checkPaths = {
    root: rootPath
  };
  if (skipBuild || performedBuild) {
    checkPaths.worker = joinPath(rootPath, workerDir);
    if (!workerOnly) {
      checkPaths.assets = joinPath(rootPath, assetsDir);
    }
  }
  for (const pathType of Object.keys(checkPaths)) {
    await checkPath(checkPaths[pathType], pathType);
  }
  const addressRegex = /^https:\/\/(?:[\w-]+\.)*[\w-]+|^https:\/\/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/;
  if (!addressRegex.test(config.deploymentUrl)) {
    throw new Error(`Invalid deployment service URL: ${config.deploymentUrl}`);
  }
}
async function checkPath(path2, pathType) {
  if (!await fileExists(path2)) {
    if (pathType === "assets") {
      outputWarn(
        `Use the "workerOnly" flag to perform a worker-only deployment.`,
        stderrLogger
      );
    }
    throw new Error(`Path not found: ${path2}`);
  }
}
function convertKeysToCamelCase(obj) {
  if (typeof obj === "object") {
    return Object.keys(obj).reduce((result, key) => {
      const camelCaseKey = key.replace(
        /([-_][a-z])/gi,
        ($1) => $1.toUpperCase().replace("-", "").replace("_", "")
      );
      if (obj[key] === void 0) {
        throw new Error(`Invalid token: ${key} is undefined`);
      }
      result[camelCaseKey] = convertKeysToCamelCase(obj[key]);
      return result;
    }, {});
  }
  return obj;
}

export { Header, authBypassTokenDurationParse, deployDefaults, errorHandler, getBuildCommandFromLockFile, isClientError, loadPackageJson, maxLabelLength, parseToken, stderrLogger, verifyConfig };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=utils.js.map