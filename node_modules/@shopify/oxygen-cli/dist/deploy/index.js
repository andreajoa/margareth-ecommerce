import { outputSuccess, outputWarn } from '@shopify/cli-kit/node/output';
import { stderrLogger, verifyConfig } from '../utils/utils.js';
export { parseToken } from '../utils/utils.js';
import { initializeBugsnag, getBugsnag, sanitizeError } from '../utils/bugsnag.js';
import { MetricsExporter, MetricName } from '../utils/metrics-exporter.js';
import { buildInitiate } from './build-initiate.js';
import { buildCancel } from './build-cancel.js';
import { getUploadFiles } from './get-upload-files.js';
import { deploymentInitiate } from './deployment-initiate.js';
import { deploymentComplete } from './deployment-complete.js';
import { verifyDeployment } from './verify-deployment.js';
import { deploymentCancel } from './deployment-cancel.js';
import { uploadFiles } from './upload-files.js';
import { verifyDeploymentCompleted } from './verify-deployment-completed.js';
import { VerificationError, DeploymentCompletedVerificationError } from './types.js';
import { buildProject } from './build-project.js';
import { getMetadata, createLabels, getEnvironmentInput } from './metadata.js';

async function createDeploy(options) {
  const cliStartTime = performance.now();
  initializeBugsnag(!options.config.bugsnag);
  const Bugsnag = getBugsnag();
  Bugsnag?.addMetadata("config", {
    ...options.config,
    deploymentToken: { ...options.config.deploymentToken, accessToken: "***" },
    rootPath: "***"
  });
  const { config, hooks } = options;
  const logger = options.logger ?? stderrLogger;
  const build = {};
  let buildCompleted;
  let deployment;
  let metricsExporter;
  try {
    const metadata = await getMetadata(config, logger);
    const labels = createLabels(metadata);
    const environment = getEnvironmentInput(config, metadata);
    Bugsnag?.addMetadata("metadata", {
      environment,
      labels,
      metadata
    });
    metricsExporter = new MetricsExporter({
      ciProvider: metadata.name || "unknown",
      rootPath: config.rootPath
    });
    if (!config.workerOnly && !config.skipBuild) {
      const buildInitiateResponse = await buildInitiate({
        config,
        environment,
        labels,
        logger
      });
      build.id = buildInitiateResponse.build.id;
      build.assetPath = buildInitiateResponse.build.assetPath;
    }
    if (!config.skipBuild) {
      await buildProject({
        config,
        assetPath: build.assetPath,
        hooks,
        metricsExporter
      });
      await verifyConfig({ config, performedBuild: true });
    }
    buildCompleted = true;
    const manifest = await getUploadFiles(config, metricsExporter);
    Bugsnag?.addMetadata("manifest", manifest);
    const deploymentInitiateInput = build.id ? { buildId: build.id, manifest } : { environment, manifest, labels };
    deployment = await deploymentInitiate({
      config,
      input: deploymentInitiateInput,
      logger
    });
    await uploadFiles({
      config,
      targets: deployment.deploymentTargets,
      hooks,
      logger,
      metricsExporter
    });
    const deploymentCompleteRequestStartTime = performance.now();
    const deploymentCompleteOp = await deploymentComplete(
      config,
      deployment.deployment.id
    );
    metricsExporter.add(MetricName.TotalTime, performance.now() - cliStartTime);
    await verifyDeploymentCompleted(
      {
        config,
        hooks,
        logger,
        timeoutInSeconds: deployment.deploymentConfiguration.timeoutInSeconds
      },
      deployment.deployment.id
    );
    metricsExporter.add(
      MetricName.DeploymentCompletedTime,
      performance.now() - deploymentCompleteRequestStartTime
    );
    if (!config.skipVerification) {
      await verifyDeployment({
        config,
        url: deploymentCompleteOp.deployment.url,
        logger,
        hooks
      });
      metricsExporter.add(
        MetricName.DeploymentRoutableTime,
        performance.now() - deploymentCompleteRequestStartTime
      );
    }
    const completedDeployment = {
      url: deploymentCompleteOp.deployment.url
    };
    let successMessage = `
The deployment can be reached at the ${completedDeployment.url} preview URL`;
    if (deploymentCompleteOp.authBypassToken) {
      completedDeployment.authBypassToken = deploymentCompleteOp.authBypassToken;
      successMessage += `. The auth bypass token for the deployment is ${completedDeployment.authBypassToken}`;
    }
    outputSuccess(successMessage, logger);
    return completedDeployment;
  } catch (error) {
    if (config.bugsnag && Bugsnag && (error instanceof Error || typeof error === "string")) {
      Bugsnag.notify(sanitizeError(error, config.rootPath));
    }
    if (!(error instanceof Error)) {
      console.error("Unknown error", error);
      return Promise.reject(new Error("Unknown error"));
    }
    if (error instanceof VerificationError || error instanceof DeploymentCompletedVerificationError) {
      outputWarn(error.message, logger);
    } else if (build.id && !buildCompleted) {
      outputWarn(
        `Build failed with: ${error.message}, cancelling build.`,
        logger
      );
      await buildCancel({
        config,
        buildId: build.id,
        reason: error.message,
        logger
      }).catch((err) => {
        if (err instanceof Error) {
          outputWarn(`Failed to cancel build: ${err.message}`, logger);
        }
      });
    } else if (deployment?.deployment.id) {
      outputWarn(
        `Deployment failed with: ${error.message}, cancelling deployment.`,
        logger
      );
      await deploymentCancel({
        config,
        deploymentId: deployment.deployment.id,
        reason: error.message,
        logger
      }).catch((err) => {
        if (err instanceof Error) {
          outputWarn(`Failed to cancel deployment: ${err.message}`, logger);
        }
      });
    }
    return Promise.reject(error);
  } finally {
    metricsExporter?.export();
  }
}

export { createDeploy };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map