import { ciPlatform } from '@shopify/cli-kit/node/context/local';
import { getLatestGitCommit } from '@shopify/cli-kit/node/git';
import { outputWarn } from '@shopify/cli-kit/node/output';
import { maxLabelLength } from '../utils/utils.js';

async function getMetadata(config, logger) {
  const ciInfo = ciPlatform();
  const metadata = ciInfo.metadata ?? {};
  try {
    const gitCommit = await latestCommit(config.rootPath);
    if (!metadata.actor) {
      metadata.actor = gitCommit.author_name;
    }
    if (!metadata.commitDate) {
      metadata.commitDate = gitCommit.date;
    }
    if (!metadata.commitMessage) {
      metadata.commitMessage = gitCommit.message;
    }
    if (gitCommit.branch) {
      metadata.branch = gitCommit.branch;
    }
    if (gitCommit.hash) {
      metadata.commitSha = gitCommit.hash;
    }
  } catch (error) {
    outputWarn(
      "Could not retrieve Git history, commit message will be unavailable.",
      logger
    );
  }
  return {
    name: ciInfo.isCI ? ciInfo.name : "none",
    ...metadata,
    actor: config.metadata.user ?? metadata.actor,
    commitMessage: createCommitTitle(
      config.metadata.description ?? metadata.commitMessage
    ),
    commitSha: config.metadata.version ?? metadata.commitSha,
    url: config.metadata.url ?? metadata.url
  };
}
async function latestCommit(path) {
  const gitCommit = await getLatestGitCommit(path);
  const branch = (/HEAD -> ([^,]*)/.exec(gitCommit.refs) || [])[1];
  const headRef = process.env.GITHUB_HEAD_REF;
  if (!headRef) {
    return {
      ...gitCommit,
      branch
    };
  }
  const match = /Merge ([\w\d]+) into [\w\d]+/.exec(gitCommit.message);
  return {
    ...gitCommit,
    branch: headRef,
    hash: match ? match[1] : gitCommit.hash
  };
}
function createCommitTitle(commitMessage) {
  if (!commitMessage) {
    return;
  }
  let title = commitMessage.split(/\r?\n/)[0]?.trim() || "";
  let jsonTitle = JSON.stringify(title);
  let isTruncated = false;
  while (jsonTitle.length > maxLabelLength) {
    const lastSpaceIndex = title.lastIndexOf(" ", maxLabelLength - 3);
    title = `${title.substring(
      0,
      lastSpaceIndex > -1 ? lastSpaceIndex : maxLabelLength - 3
    )}`.trimEnd();
    isTruncated = true;
    jsonTitle = JSON.stringify(title);
  }
  return isTruncated ? `${title}...` : title;
}
function getEnvironmentInput(config, metadata) {
  if (config.defaultEnvironment) {
    return void 0;
  }
  const tag = config.environmentTag || metadata.branch;
  return tag ? { tag } : void 0;
}
function createLabels(metadata) {
  const labels = [];
  const checkLabel = (labelKey, labelValue) => {
    const jsonString = JSON.stringify(labelValue);
    if (jsonString.length > maxLabelLength) {
      throw new Error(
        `Provided ${labelKey} metadata exceeds maximum length (max ${maxLabelLength} characters).`
      );
    }
    const label = `${labelKey}=${jsonString}`;
    labels.push(label);
  };
  if (metadata.name !== "none") {
    labels.push(`ci-platform=${JSON.stringify(metadata.name)}`);
  }
  if (metadata.name !== "unknown") {
    const keyMapping2 = {
      attempt: "attempt",
      run: "runId"
    };
    for (const [key, value] of Object.entries(keyMapping2)) {
      const metadataKey = key;
      if (metadata[metadataKey]) {
        labels.push(
          `${metadata.name}-${value}=${JSON.stringify(metadata[metadataKey])}`
        );
      }
    }
  }
  const keyMapping = {
    actor: "user",
    branch: "branch",
    commitDate: "commit-date",
    commitMessage: "description",
    commitSha: "version",
    url: "url"
  };
  for (const [key, value] of Object.entries(keyMapping)) {
    const metadataKey = key;
    if (metadata[metadataKey]) {
      checkLabel(value, metadata[metadataKey]);
    }
  }
  return labels;
}

export { createLabels, getEnvironmentInput, getMetadata };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=metadata.js.map