{"version":3,"sources":["../../src/deploy/metadata.ts"],"names":["keyMapping"],"mappings":"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","sourcesContent":["import {ciPlatform, CIMetadata} from '@shopify/cli-kit/node/context/local';\nimport {getLatestGitCommit} from '@shopify/cli-kit/node/git';\nimport {Logger, outputWarn} from '@shopify/cli-kit/node/output';\n\nimport {maxLabelLength} from '../utils/utils.js';\n\nimport {DeploymentConfig, EnvironmentInput} from './types.js';\n\nexport type Metadata = CIMetadata & {\n  commitDate?: string;\n  name?: string;\n};\n\nexport async function getMetadata(\n  config: DeploymentConfig,\n  logger: Logger,\n): Promise<Metadata> {\n  const ciInfo = ciPlatform();\n  const metadata: Metadata = ciInfo.metadata ?? {};\n\n  try {\n    const gitCommit = await latestCommit(config.rootPath);\n\n    // Only update actor, commitDate, and commitMessage if we don't already have\n    // the data from CI.\n    if (!metadata.actor) {\n      metadata.actor = gitCommit.author_name;\n    }\n    if (!metadata.commitDate) {\n      metadata.commitDate = gitCommit.date;\n    }\n    if (!metadata.commitMessage) {\n      metadata.commitMessage = gitCommit.message;\n    }\n\n    // Always update the following keys with the Git information if it's\n    // available since we may modify what the values are.\n    if (gitCommit.branch) {\n      metadata.branch = gitCommit.branch;\n    }\n    if (gitCommit.hash) {\n      metadata.commitSha = gitCommit.hash;\n    }\n  } catch (error) {\n    outputWarn(\n      'Could not retrieve Git history, commit message will be unavailable.',\n      logger,\n    );\n  }\n\n  return {\n    name: ciInfo.isCI ? ciInfo.name : 'none',\n    ...metadata,\n    actor: config.metadata.user ?? metadata.actor,\n    commitMessage: createCommitTitle(\n      config.metadata.description ?? metadata.commitMessage,\n    ),\n    commitSha: config.metadata.version ?? metadata.commitSha,\n    url: config.metadata.url ?? metadata.url,\n  };\n}\n\nasync function latestCommit(path?: string) {\n  const gitCommit = await getLatestGitCommit(path);\n  const branch = (/HEAD -> ([^,]*)/.exec(gitCommit.refs) || [])[1];\n\n  // If this variable is set it means we are in a GitHub action using the\n  // pull_request trigger which creates a merge commit and we'll need to\n  // manually extract the commit details.\n  // eslint-disable-next-line no-process-env\n  const headRef = process.env.GITHUB_HEAD_REF;\n\n  if (!headRef) {\n    return {\n      ...gitCommit,\n      branch,\n    };\n  }\n\n  const match = /Merge ([\\w\\d]+) into [\\w\\d]+/.exec(gitCommit.message);\n\n  return {\n    ...gitCommit,\n    branch: headRef,\n    hash: match ? match[1] : gitCommit.hash,\n  };\n}\n\nfunction createCommitTitle(commitMessage?: string): string | undefined {\n  if (!commitMessage) {\n    return;\n  }\n\n  let title = commitMessage.split(/\\r?\\n/)[0]?.trim() || '';\n  let jsonTitle = JSON.stringify(title);\n  let isTruncated = false;\n\n  while (jsonTitle.length > maxLabelLength) {\n    const lastSpaceIndex = title.lastIndexOf(' ', maxLabelLength - 3);\n    title = `${title.substring(\n      0,\n      lastSpaceIndex > -1 ? lastSpaceIndex : maxLabelLength - 3,\n    )}`.trimEnd();\n    isTruncated = true;\n    jsonTitle = JSON.stringify(title);\n  }\n\n  return isTruncated ? `${title}...` : title;\n}\n\nexport function getEnvironmentInput(\n  config: DeploymentConfig,\n  metadata: CIMetadata,\n): EnvironmentInput | undefined {\n  if (config.defaultEnvironment) {\n    return undefined;\n  }\n\n  const tag = config.environmentTag || metadata.branch;\n  return tag ? {tag} : undefined;\n}\n\nexport function createLabels(metadata: Metadata): string[] {\n  const labels: string[] = [];\n\n  const checkLabel = (labelKey: string, labelValue: string) => {\n    const jsonString = JSON.stringify(labelValue);\n    if (jsonString.length > maxLabelLength) {\n      throw new Error(\n        `Provided ${labelKey} metadata exceeds maximum length (max ${maxLabelLength} characters).`,\n      );\n    }\n    const label = `${labelKey}=${jsonString}`;\n    labels.push(label);\n  };\n\n  if (metadata.name !== 'none') {\n    labels.push(`ci-platform=${JSON.stringify(metadata.name)}`);\n  }\n\n  if (metadata.name !== 'unknown') {\n    const keyMapping = {\n      attempt: 'attempt',\n      run: 'runId',\n    };\n\n    for (const [key, value] of Object.entries(keyMapping)) {\n      const metadataKey = key as keyof Metadata;\n      if (metadata[metadataKey]) {\n        labels.push(\n          `${metadata.name}-${value}=${JSON.stringify(metadata[metadataKey])}`,\n        );\n      }\n    }\n  }\n\n  const keyMapping = {\n    actor: 'user',\n    branch: 'branch',\n    commitDate: 'commit-date',\n    commitMessage: 'description',\n    commitSha: 'version',\n    url: 'url',\n  };\n\n  for (const [key, value] of Object.entries(keyMapping)) {\n    const metadataKey = key as keyof Metadata;\n    if (metadata[metadataKey]) {\n      checkLabel(value, metadata[metadataKey]!);\n    }\n  }\n\n  return labels;\n}\n"]}