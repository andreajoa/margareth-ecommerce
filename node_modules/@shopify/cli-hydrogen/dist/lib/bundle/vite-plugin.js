import { relativePath, joinPath } from '@shopify/cli-kit/node/path';
import { getAnalyzerTemplate, BUNDLE_ANALYZER_JSON_FILE, BUNDLE_ANALYZER_HTML_FILE, injectAnalyzerTemplateData } from './analyzer.js';

function hydrogenBundleAnalyzer(pluginOptions) {
  let config;
  return {
    name: "hydrogen:bundle-analyzer",
    configResolved(_config) {
      config = _config;
    },
    async generateBundle(options, bundle) {
      if (!config.build.ssr) return;
      const { root } = config;
      const workerFile = Object.values(bundle).find(
        (chunk) => chunk.type === "chunk"
      );
      if (!workerFile || workerFile.type !== "chunk" || !workerFile.facadeModuleId || !options.dir) {
        return;
      }
      const analysisTemplate = await getAnalyzerTemplate().catch(() => null);
      if (!analysisTemplate) {
        console.warn("Bundle analyzer template not found");
        return;
      }
      const allModIds = new Set(Object.keys(workerFile.modules));
      const modsToAnalyze = [];
      for (const modId of allModIds) {
        if (isViteCjsHelper(modId) || isViteTransformHelper(modId)) continue;
        const mod = this.getModuleInfo(modId);
        if (!mod?.id) continue;
        modsToAnalyze.push(mod);
        for (const importedId of [
          ...mod.importedIds,
          ...mod.dynamicallyImportedIds
        ]) {
          if (!isViteCjsHelper(importedId) && !isViteTransformHelper(importedId)) {
            allModIds.add(importedId);
          }
        }
      }
      const modsMeta = /* @__PURE__ */ new Map();
      const renderedSizes = /* @__PURE__ */ new Map();
      const resultError = await Promise.all(
        modsToAnalyze.map(async (mod) => {
          const relativeModId = relativePath(root, mod.id);
          const modBundleInfo = workerFile.modules[mod.id];
          const originalCodeBytes = modBundleInfo?.originalLength ?? mod.code?.length ?? 0;
          let resultingCodeBytes = modBundleInfo?.renderedLength ?? 0;
          if (pluginOptions?.minify && modBundleInfo?.code) {
            const minifiedCode = await pluginOptions.minify(modBundleInfo.code, mod.id).catch(() => null);
            if (minifiedCode) resultingCodeBytes = minifiedCode.length;
          }
          renderedSizes.set(relativeModId, resultingCodeBytes);
          const resolveImportString = (importString) => this.resolve(importString, mod.id);
          let isESM = !mod.code || /(^\s*export\s+[\w\{]|^\s*import\s+[\w\{'"]|\bimport\()|\bcreateRequire\(/ms.test(
            mod.code
          ) || !/((^|\b)exports\b|\brequire\()/.test(mod.code);
          const staticImportsMeta = createImportsMeta(
            mod.importedIds,
            "import-statement",
            root,
            resolveImportString,
            mod.code
          );
          const dynamicImportsMeta = createImportsMeta(
            mod.dynamicallyImportedIds,
            "dynamic-import",
            root,
            resolveImportString,
            mod.code
          );
          const importsMeta = (await Promise.all([...staticImportsMeta, ...dynamicImportsMeta])).reduce((acc, { importedId, ...meta }) => {
            if (isViteCjsHelper(importedId)) {
              isESM = false;
            } else if (!isViteTransformHelper(importedId)) {
              acc.push(meta);
            }
            return acc;
          }, []);
          modsMeta.set(relativeModId, {
            bytes: originalCodeBytes,
            format: isESM ? "esm" : "cjs",
            imports: importsMeta
          });
        })
      ).then(() => null).catch((error) => error);
      if (resultError) {
        console.warn(
          "Bundle analyzer failed to analyze the bundle:",
          resultError
        );
        return;
      }
      const inputs = Object.fromEntries(modsMeta.entries());
      const metafile = {
        inputs,
        outputs: {
          [relativePath(root, joinPath(options.dir, workerFile.fileName))]: {
            imports: workerFile.imports,
            exports: workerFile.exports,
            entryPoint: relativePath(root, workerFile.facadeModuleId),
            bytes: workerFile.code.length ?? 0,
            inputs: Object.entries(inputs).reduce((acc, [key, item]) => {
              acc[key] = {
                bytesInOutput: renderedSizes.get(key) ?? item.bytes ?? 0
              };
              return acc;
            }, {})
          }
        }
      };
      bundle[BUNDLE_ANALYZER_JSON_FILE] = {
        type: "asset",
        fileName: BUNDLE_ANALYZER_JSON_FILE,
        name: BUNDLE_ANALYZER_JSON_FILE,
        needsCodeReference: false,
        source: JSON.stringify(metafile, null, 2)
      };
      bundle[BUNDLE_ANALYZER_HTML_FILE] = {
        type: "asset",
        fileName: BUNDLE_ANALYZER_HTML_FILE,
        name: BUNDLE_ANALYZER_HTML_FILE,
        needsCodeReference: false,
        source: injectAnalyzerTemplateData(
          analysisTemplate,
          JSON.stringify(metafile)
        )
      };
    }
  };
}
function isViteCjsHelper(id) {
  return /(commonjsHelpers\.js$|\?commonjs\-)/.test(id);
}
function isViteTransformHelper(id) {
  return id.endsWith("?transform-only");
}
async function findOriginalImportName(filepath, importerCode, resolve) {
  const matches = importerCode.matchAll(/import\s[^'"]*?['"]([^'"]+)['"]/g) ?? [];
  for (const [, match] of matches) {
    if (match) {
      const resolvedMod = await resolve(match);
      if (resolvedMod?.id === filepath) {
        return match;
      }
    }
  }
  return filepath;
}
function createImportsMeta(ids, kind, root, resolveImportString, code) {
  return ids.map(async (importedId) => {
    return {
      importedId,
      path: relativePath(root, importedId),
      kind,
      original: code ? await findOriginalImportName(importedId, code, resolveImportString) : importedId
    };
  });
}

export { hydrogenBundleAnalyzer };
