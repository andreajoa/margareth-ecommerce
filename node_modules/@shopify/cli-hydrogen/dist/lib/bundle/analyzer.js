import { joinPath, dirname } from '@shopify/cli-kit/node/path';
import { fileExists, readFile, writeFile } from '@shopify/cli-kit/node/fs';
import colors from '@shopify/cli-kit/node/colors';
import { renderWarning } from '@shopify/cli-kit/node/ui';
import { getAssetsDir } from '../build.js';

const BUNDLE_ANALYZER_JSON_FILE = "metafile.server.json";
const BUNDLE_ANALYZER_HTML_FILE = "server-bundle-analyzer.html";
async function classicBuildBundleAnalysis(buildPath) {
  const workerBuildPath = joinPath(buildPath, "worker");
  const serverMetafile = BUNDLE_ANALYZER_JSON_FILE;
  const clientMetafile = "metafile.js.json";
  const hasMetafile = (await Promise.all([
    fileExists(joinPath(workerBuildPath, serverMetafile)),
    fileExists(joinPath(workerBuildPath, clientMetafile))
  ])).every(Boolean);
  if (!hasMetafile) return null;
  try {
    await Promise.all([
      classicWriteBundleAnalyzerFile(
        workerBuildPath,
        serverMetafile,
        "worker-bundle-analyzer.html"
      ),
      classicWriteBundleAnalyzerFile(
        workerBuildPath,
        clientMetafile,
        "client-bundle-analyzer.html"
      )
    ]);
    return "file://" + joinPath(workerBuildPath, "worker-bundle-analyzer.html");
  } catch (thrown) {
    const error = thrown;
    renderWarning({
      headline: "Could not generate bundle analysis",
      body: error?.stack ?? error?.message ?? error
    });
    return null;
  }
}
async function getAnalyzerTemplate() {
  return readFile(await getAssetsDir("bundle", "analyzer.html"));
}
function injectAnalyzerTemplateData(analysisTemplate, metafile) {
  return analysisTemplate.replace(
    `globalThis.METAFILE = '';`,
    `globalThis.METAFILE = '${Buffer.from(metafile, "utf-8").toString(
      "base64"
    )}';`
  );
}
async function classicWriteBundleAnalyzerFile(workerBuildPath, metafileName, outputFile) {
  const metafile = await readFile(joinPath(workerBuildPath, metafileName), {
    encoding: "utf8"
  });
  await writeFile(
    joinPath(workerBuildPath, outputFile),
    injectAnalyzerTemplateData(await getAnalyzerTemplate(), metafile)
  );
}
async function getBundleAnalysisSummary(distPath) {
  try {
    const esbuild = await import('esbuild');
    const metafileAnalysis = await esbuild.analyzeMetafile(
      await readFile(joinPath(distPath, BUNDLE_ANALYZER_JSON_FILE)),
      { color: true }
    );
    return "    \u2502\n " + metafileAnalysis.split("\n").filter((line) => {
      const match = line.match(
        /(.*)(node_modules\/|server-assets-manifest:|server-entry-module:)(react-dom|@remix-run|@shopify\/hydrogen|react-router|react-router-dom)\/(.*)/g
      );
      return !match;
    }).slice(2, 12).join("\n").replace(/dist\/worker\/_assets\/.*$/ms, "\n").replace(/\n/g, "\n ").replace(/(\.\.\/)+node_modules\//g, (match) => colors.dim(match));
  } catch (error) {
    console.warn(
      "Could not generate bundle analysis summary:",
      error.message
    );
  }
}
function classicGetBundleAnalysisSummary(bundlePath) {
  return getBundleAnalysisSummary(dirname(bundlePath));
}

export { BUNDLE_ANALYZER_HTML_FILE, BUNDLE_ANALYZER_JSON_FILE, classicBuildBundleAnalysis, classicGetBundleAnalysisSummary, getAnalyzerTemplate, getBundleAnalysisSummary, injectAnalyzerTemplateData };
